# 2023/02/08

![](https://velog.velcdn.com/images/ririti/post/f7b95dd4-05b4-4be0-a47f-f8abb01c1f3c/image.png)
> HTTP(Hypertext Transfer Protocol)
> - 클라이언트와 서버 간 통신을 위한 프로토콜

- HTTP를 이용한 전달은 TCP 기반으로 이루어 져있으며 Application층에 존재 한다.


## HTTP/1.0

기본 HTTP/0.9는 Get method만 있으며 HTML 리소스만 처리 가능했지만 1.0으로 와선 css, image등 여러 파일을 보내고 받을 수 있도록 설계 되었다.(Post method추가)

- 통신시에 매번 새로운 연결을 해야함

    - 하나의 데이터를 받을 때 마다 서버측에서 연결을 끊음
    - 요청 컨텐츠마다 TCP 세션

- 하나의 IP에 여러 개의 도메인을 운영할 수 없음

- 기본적으로 Connection 당 하나의 요청을 처리

    - 동시 전송은 불가능하고 하나의 요청에 대한 응답이 온 후 다음 요청을 처리
    - 멀티미디어 리소스들이 있는 상황에서 Network Latency를 발생

#### Network Latency
- 네트워크 통신의 지연입니다. 네트워크를 통해 데이터를 전송하는 데 걸리는 시간을 보여 준다.
- 네트워크 지연 시간이 길면 애플리케이션 성능이 저하되고, 일정 수준 이상으로 지연 시간이 길어지면 장애가 발생


## HTTP/1.1

HTTP의 공식 표준 버전으로써 GET, POST 외에도 PUT, DELETE가 생겼으며, 하나의 TCP 연결을 재사용하여 많은 컨텐츠를 전달할 수있는 지속적 연결 기술이 추가 되었다.

### HTTP 파이프라이닝(Pipelining)
> 브라우저가 웹 서버에 여러 개의 컨텐츠를 요청했을 때 이전 요청에 대한 응답을 완전하게 받지 않더라도 지속적으로 연결로 확보한 하나의 TCP 연결 내에서 미리 다음 요청에 대한 처리를 시작하면서 전체적인 전달 시간을 줄이는 방식

#### 문제점
- 파이프라이닝을 정확히 구현해내기가 복잡하다.

- HOL(Head of Line) Blocking

    - 어떤 요청에 병목이 생겨서 전체 latency가 증가하는 것
    - TCP를 사용하는 통신에서 패킷은 정확한 순서대로 처리되어야 한다.
        - 수신측은 송신 측과 주고 받은 시퀀스 번호를 참고하여 패킷을 조립해야 하기 때문
    - 패킷이 손실될 경우 온전한 데이터로 조립하기 어렵기 때문에 패킷이 제대로 전달되지 않았을 경우 재전송 해야 한다.
    - 요청 받은 순서대로 응답해야 하므로 먼저한 요청을 처리하고 나서 뒤의 요청을 처리하기 때문에 요청이 지연된다.

![](https://velog.velcdn.com/images/ririti/post/17b8e388-c31d-4ff0-88f2-6c247dc3a810/image.png)
short-lived connection은 HTTP/1.0, 오른쪽 두개는 HTTP/1.1에 해당

### 영속적인 커넥션(Persistent Connection)
- 지정한 시간동안 connection을 닫지않으며 여러 요청에 재사용함으로써, 새로운 TCP 핸드셰이크를 하는 비용을 아끼고, 성능 향상에 기여

- 영속적인 커넥션도 단점이 있는데 실제 데이터를 보내지 않는 상황에서도 통신을 열어서 유지해야 하기 때문에 서버 리소스를 낭비하게 된다.


## HTTP/2.0

### 등장배경
HTTP/1.1은 커넥션 하나를 통해 요청 하나를 보내고 그에 대해 응답 하나만을 받는 HTTP의 메시지 교환 방식은 단순했지만, 응답을 받아야만 그다음 요청을 보낼 수 있기 때문에 latency를 피할 순 없었기에 더 효율적이고 빠른 HTTP가 필요로 했고 이러한 요구로 만들어진 것이 구굴의 SPDY 프로토콜이다.

### 특징

1. HTTP 메시지 전송 방식의 변화
    - 바이너리 프레이밍 계층을 사용하여 전송 속도는 높이고 오류 발생 가능성은 낮추었다.


2. 헤더 압축
   ![](https://velog.velcdn.com/images/ririti/post/6a88ba78-0732-4fd4-a913-3ae6b0731fbf/image.png)
> HTTP/1.1에서는 헤더를 아무런 압축 없이 그대로 전송되어 웹페이지 하나를 방문할 때의 요청이 만히 않았기 때문에 헤더 크기가 문제가 되진 않았지만 요즘은 웹페이지를 하나 보기 위해서는 수십 수백의 요청을 보내기 때문에 실질적으로 영향을 끼친다. 이를 위해 헤더를 압축

- 헤더의 크기를 줄여 페이지 로드 시간을 감소시켰다.
- HTTP/2는 클라이언트와 서버 사이에 가상 테이블을 만들어서 동일하고 중복되는 헤더 값들을 테이블에 저장하고 참고하는 방식으로 중복 전달을 제거

- 가상 테이블은 정적 테이블과 동적 테이블로 나뉜다.

    - 정적 테이블은 미리 정의된 자주 사용되는 헤더 필드를 저장한다.
    - 동적 테이블은 클라이언트와 서버가 주고 받은 값들을 업데이트한다.

- HPACK을 사용해 허프만 알고리즘 방식으로 헤더를 압축

3. multiplexing과 Stream
    - Pipelining의 개선안으로 하나의 Connection을 통해 동시에 여러 개의 메세지를 주고 받을 수 있음
    - 응답은 요청 순서에 상관없이 Stream으로 받기 때문에 HOL Blocking 문제도 해결
    - 리소스간 우선 순위를 설정 가능하여 우선순위가 높을수록 응답을 빨리 가능하게 한다.

## HTTP/3.0
- HTTP/3.0은 기존 TCP위에서 돌아가는 버전과는 달리 QUIC라는 계층 위에서 돌아가며 UDP 기반으로 돌아간다.
- HTTP/3.0에서 부터는 https만 사용
- 최근 네이버가 국내 포탈에서는 최초로 HTTP/3.0을 도입



### QUIC(Quick UDP Internet Connections)
![](https://velog.velcdn.com/images/ririti/post/1e8af5e2-d454-45a9-b2ac-3d7d9b49008f/image.png)

> QUIC은 UDP를 채택해 TCP의 성능을 개선하려는 기술

- 전달 속도의 향상과 더불어 클라이언트와 서버의 연결 수를 최소화하고 대역폭을 예상해 패킷 혼잡을 피하는 것이 QUIC의 주요 특징

- 이전에 클라이언트가 한 번이라도 접속했던 서버라면, 별도의 정보 교환 없이 바로 데이터를 보내는 기술
